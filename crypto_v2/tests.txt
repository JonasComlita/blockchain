# Blockchain Security Test Plan - Production Launch

## Critical Priority Tests (Must Pass Before Launch)

### 1. Consensus & State Integrity Tests

#### 1.1 State Transition Validation
- [ ] **Double-spend prevention**: Attempt to spend same tokens in parallel transactions
- [ ] **Nonce enforcement**: Submit transactions with duplicate, skipped, or out-of-order nonces
- [ ] **Balance underflow**: Try to transfer/stake more tokens than available
- [ ] **State root verification**: Verify state root matches after replaying all transactions
- [ ] **Fork choice correctness**: Test LMD GHOST with competing chains

#### 1.2 AMM Pool Security
- [ ] **Constant product invariant**: Verify x*y=k holds after all swaps
- [ ] **Minimum transaction enforcement**: Test $1.00 minimum (both directions)
- [ ] **Maximum size limit**: Attempt swaps >50% of pool reserves
- [ ] **Fee calculation accuracy**: Verify 0.3% fee is correctly applied
- [ ] **Integer overflow/underflow**: Test with extreme values
- [ ] **Price manipulation**: Attempt sandwich attacks, front-running
- [ ] **Liquidity removal attacks**: Try to drain pool unfairly

#### 1.3 Multi-Asset Balance System
- [ ] **Balance isolation**: Verify native/USD balances are independent
- [ ] **Cross-asset attacks**: Try to spend USD as native tokens (and vice versa)
- [ ] **Negative balance prevention**: Test all paths that modify balances
- [ ] **LP token accounting**: Verify LP tokens match actual pool shares

### 2. Transaction Validation Tests

#### 2.1 Cryptographic Security
- [ ] **Signature verification**: Reject invalid/missing signatures
- [ ] **Signature malleability**: Test for signature replay attacks
- [ ] **Public key recovery**: Verify address derivation is deterministic
- [ ] **VRF proof validation**: Test leader election with invalid VRF proofs

#### 2.2 Transaction Types
- [ ] **TRANSFER**: Test native/USD transfers, insufficient funds, invalid recipients
- [ ] **MINT_USD_TOKEN**: Verify only PAYMENTS_ORACLE_ADDRESS can mint
- [ ] **STAKE**: Test minimum stake, unstaking, validator set updates
- [ ] **BOND_MINT**: Verify bonding curve calculations, reserve pool updates
- [ ] **RESERVE_BURN**: Test buyback price (98% of market), outflow reserve limits
- [ ] **DEPLOY_RESERVE_LIQUIDITY**: Verify only RESERVE_ADMIN_ADDRESS can deploy
- [ ] **SWAP**: All AMM restrictions (min/max/fees)
- [ ] **ADD_LIQUIDITY/REMOVE_LIQUIDITY**: LP token math, proportional withdrawals

#### 2.3 Permission & Authorization
- [ ] **Oracle restrictions**: Non-oracles cannot mint USD or deploy liquidity
- [ ] **Admin restrictions**: Non-admins cannot call admin functions
- [ ] **Chain ID validation**: Reject transactions from wrong chain

### 3. Economic Attack Vectors

#### 3.1 Tokenomics Exploits
- [ ] **Supply manipulation**: Verify total_supply = minted - burned at all times
- [ ] **Reserve pool draining**: Attempt to extract more USD than available
- [ ] **Bonding curve bypass**: Try to mint tokens cheaper than bonding curve
- [ ] **Price oracle manipulation**: If using external prices, test manipulation

#### 3.2 AMM Exploits
- [ ] **Flash loan attacks**: Large swap → reverse swap in same block
- [ ] **Slippage attacks**: Test min_amount_out protection
- [ ] **Liquidity removal timing**: Remove liquidity right before large swaps
- [ ] **First LP exploit**: Test initial liquidity provision edge cases

### 4. Block Production & Validation

#### 4.1 Block Validity
- [ ] **Parent hash chain**: Verify parent_hash links form valid chain
- [ ] **Block size limits**: Reject blocks >MAX_BLOCK_SIZE
- [ ] **Transaction limits**: Reject blocks >MAX_TXS_PER_BLOCK
- [ ] **Timestamp validation**: Block timestamp > parent timestamp
- [ ] **PoH verification**: Verify PoH sequences are valid
- [ ] **State root mismatch**: Reject blocks with incorrect state root

#### 4.2 Leader Selection
- [ ] **VRF determinism**: Same seed always produces same leader
- [ ] **Stake weighting**: Verify higher stake = higher selection probability
- [ ] **Invalid leader rejection**: Reject blocks from non-leaders
- [ ] **No VRF key handling**: Validators without VRF can't produce blocks

### 5. Database & Storage Tests

#### 5.1 Trie (Merkle Patricia) Integrity
- [ ] **Insert/retrieve consistency**: Set keys and verify retrieval
- [ ] **Root hash determinism**: Same data = same root hash
- [ ] **Collision resistance**: Different keys don't collide
- [ ] **Large value handling**: Test with max-size values
- [ ] **Concurrent access**: Multiple threads reading/writing

#### 5.2 Database Operations
- [ ] **Crash recovery**: Kill node mid-block, verify recovery
- [ ] **Checkpoint restoration**: Restore from checkpoint, verify state
- [ ] **Database corruption**: Detect and handle corrupted entries
- [ ] **Storage limits**: Test behavior at disk space limits

## High Priority Tests (Should Pass Before Launch)

### 6. Network & P2P Tests

#### 6.1 Message Security
- [ ] **Message size limits**: Reject messages >MAX_MESSAGE_SIZE
- [ ] **Rate limiting**: Block peers exceeding message rate
- [ ] **Message deduplication**: Don't process duplicate blocks/txs
- [ ] **Timestamp validation**: Reject old/future messages
- [ ] **Malformed messages**: Handle invalid msgpack gracefully

#### 6.2 Peer Management
- [ ] **Peer banning**: Ban peers with score < -100
- [ ] **Connection limits**: Enforce MAX_PEERS and per-IP limits
- [ ] **Handshake enforcement**: Reject messages before handshake
- [ ] **Unresponsive peers**: Disconnect peers after timeout
- [ ] **Eclipse attacks**: Can't isolate node with malicious peers

#### 6.3 Network Partitions
- [ ] **Chain reorganization**: Longer chain replaces shorter
- [ ] **Fork resolution**: LMD GHOST selects correct head
- [ ] **Sync after partition**: Node syncs to longest chain
- [ ] **Attestation aggregation**: Validators attest to same head

### 7. Mempool Tests

#### 7.1 Transaction Pool Management
- [ ] **Nonce gaps**: Don't include txs with nonce gaps
- [ ] **Fee prioritization**: Higher fee txs included first
- [ ] **Replacement by fee**: Higher fee replaces lower fee
- [ ] **Expiry**: Remove transactions after TX_EXPIRY_TIME
- [ ] **Eviction**: Remove low-fee txs when mempool full
- [ ] **Per-account limits**: Enforce MAX_TXS_PER_ACCOUNT

#### 7.2 DOS Prevention
- [ ] **Spam transactions**: Flood mempool with low-fee txs
- [ ] **Large transaction data**: Submit txs with huge data fields
- [ ] **Invalid transactions**: Submit known-invalid txs

### 8. Validator Node Tests

#### 8.1 Block Production
- [ ] **Leader rotation**: Multiple validators produce blocks in order
- [ ] **Block timing**: Blocks produced every BLOCK_TIME seconds
- [ ] **Transaction inclusion**: Valid mempool txs get included
- [ ] **Empty blocks**: Can produce blocks with no transactions

#### 8.2 Slashing Conditions
- [ ] **Double signing**: Detect and slash double-signing validators
- [ ] **Invalid blocks**: Slash validators producing invalid blocks
- [ ] **Equivocation**: Detect and punish equivocating validators

## Medium Priority Tests (Performance & Scalability)

### 9. Performance Tests

#### 9.1 Load Testing
- [ ] **High TPS**: Test with 100+ transactions per second
- [ ] **Large blocks**: Blocks near MAX_BLOCK_SIZE
- [ ] **Many validators**: Test with 100+ validators
- [ ] **Long chains**: Validate chain with 10,000+ blocks
- [ ] **Large state**: Trie with 100,000+ accounts

#### 9.2 Resource Usage
- [ ] **Memory leaks**: Run for 24+ hours, monitor memory
- [ ] **Disk usage growth**: Verify reasonable database growth
- [ ] **CPU usage**: Block validation shouldn't peg CPU
- [ ] **Network bandwidth**: Monitor peer message overhead

### 10. Integration Tests

#### 10.1 End-to-End Scenarios
- [ ] **New user onboarding**: USD mint → swap → game fee → burn
- [ ] **Liquidity provision**: Add liquidity → swaps occur → remove liquidity
- [ ] **Reserve pool cycle**: Bond mint → reserve deploys → users swap
- [ ] **Token buyback**: Users sell to outflow reserve
- [ ] **Validator lifecycle**: Stake → produce blocks → unstake

#### 10.2 Multi-Node Tests
- [ ] **3-node network**: All nodes stay in sync
- [ ] **Network partition**: Nodes rejoin after partition
- [ ] **New node sync**: Fresh node syncs full chain
- [ ] **Validator set changes**: Nodes handle changing validators

## Lower Priority Tests (Edge Cases & Hardening)

### 11. Edge Cases

- [ ] **Genesis block**: Special handling works correctly
- [ ] **Zero balances**: Operations on accounts with 0 balance
- [ ] **Maximum values**: Test with max uint64 values
- [ ] **Empty pool**: AMM operations with empty reserves
- [ ] **Single validator**: Network with only 1 validator
- [ ] **Simultaneous blocks**: Two validators produce at same height

### 12. Upgrade & Migration Tests

- [ ] **Schema changes**: Can upgrade database schema
- [ ] **Hard forks**: Can activate new rules at specific height
- [ ] **Backward compatibility**: Old nodes can read new blocks (until fork)

## Test Execution Strategy

### Phase 1: Unit Tests (Week 1-2)
- All cryptographic functions
- Individual transaction types
- AMM calculations
- Trie operations
- Mempool logic

### Phase 2: Integration Tests (Week 2-3)
- Block validation pipeline
- State transitions
- Multi-transaction blocks
- Fork choice

### Phase 3: Network Tests (Week 3-4)
- 3-5 node testnet
- Network partitions
- Peer misbehavior
- Sync scenarios

### Phase 4: Load Testing (Week 4-5)
- Sustained high load
- Stress testing limits
- Resource monitoring
- Performance profiling

### Phase 5: Security Audit (Week 5-6)
- External audit of critical paths
- Fuzzing all input handlers
- Economic attack simulations
- Formal verification (if possible)

### Phase 6: Testnet (Week 6-8)
- Public testnet with external validators
- Bug bounty program
- Real user testing
- Monitor for unexpected behaviors

## Critical Security Checklist

Before production launch, verify:

- [ ] All critical and high priority tests pass 100%
- [ ] No known exploits or vulnerabilities
- [ ] External security audit completed
- [ ] Economic models validated by experts
- [ ] Recovery procedures documented and tested
- [ ] Monitoring and alerting in place
- [ ] Incident response plan ready
- [ ] Bug bounty program active
- [ ] Circuit breakers for emergency shutdown
- [ ] Upgrade mechanism tested

## Continuous Testing (Post-Launch)

- [ ] Automated test suite runs on every commit
- [ ] Fuzzing runs continuously
- [ ] Mainnet monitoring for anomalies
- [ ] Regular penetration testing
- [ ] Economic attack simulations
- [ ] Chaos engineering (controlled failures)

---

## Notes

**Walled Garden Restrictions**: Your system has two key protection mechanisms:
1. $1.00 minimum transaction value
2. 50% maximum pool impact per swap

These are excellent defenses against:
- Micro-transaction spam
- Single-transaction pool draining
- MEV attacks with tiny test amounts

**Areas of Concern** (flagged for extra scrutiny):
1. **Reserve Pool Deploy Logic**: Only admin can deploy, but verify math is correct
2. **Outflow Reserve Pricing**: 98% of market price - verify this doesn't enable arbitrage
3. **Integer Division**: All `/` operations should be checked for precision loss
4. **Bonding Curve**: Verify BONDING_CURVE_SLOPE prevents runaway inflation

**Test Data Sets**:
- Create realistic transaction patterns (gaming app usage)
- Adversarial patterns (attacks)
- Edge cases (extreme values)
- Randomized fuzzing inputs

-----------------------

crypto_v2/test_transaction.py ........................s.s..........ss...                                                                [100%]

======================================================== 38 passed, 4 skipped in 0.48s ========================================================

The four tests are being skipped because they require specific cryptographic key pairs for privileged accounts, namely the "payments oracle" and the "reserve admin."

Here's a breakdown:

test_oracle_can_mint_usd and test_mint_usd_updates_tokenomics: These tests require signing a transaction as the PAYMENTS_ORACLE_ADDRESS to mint new USD tokens. The tests currently generate random keys, which don't match the required oracle address, so they are skipped to avoid an authorization failure.

test_deploy_requires_usd_in_reserve_pool and test_deploy_adds_to_amm_pool: These tests need to be run as the RESERVE_ADMIN_ADDRESS to deploy liquidity from the reserve pool. Similar to the oracle tests, they are skipped because the necessary admin-specific key pair is not available in the test setup.

In short, these tests are for actions that only special, pre-defined accounts can perform, and the tests currently lack the credentials to act as those accounts.

------------------------------

jonas@fedora:~/Downloads/NetPlay-master$ PYTHONPATH=. /home/jonas/Downloads/NetPlay-master/venv/bin/pytest /home/jonas/Downloads/NetPlay-master/crypto_v2/test_state_integrity.py
/home/jonas/Downloads/NetPlay-master/venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:207: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
=========================================== test session starts ===========================================
platform linux -- Python 3.13.7, pytest-8.3.5, pluggy-1.5.0
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/jonas/Downloads/NetPlay-master
plugins: cov-6.0.0, benchmark-5.1.0, asyncio-0.25.3
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None
collected 16 items                                                                                        

crypto_v2/test_state_integrity.py ..F.............                                                  [100%]

================================================ FAILURES =================================================
________________________ TestDoubleSpendPrevention.test_double_spend_across_blocks ________________________

self = <test_state_integrity.TestDoubleSpendPrevention object at 0x7f65afba5cd0>
blockchain = <crypto_v2.chain.Blockchain object at 0x7f65afae91d0>
funded_account = {'address': b'#|\x08\xb0\xf5H*\x101~4\x9ej\xdd\xac&\xb2e\x91x', 'priv_key': <cryptography.hazmat.bindings._rust.openss...gWj5QHpOJBSp2U2zicUtmaeX8mX\n5HdOrOqcftjJ2Dgq0+DDMeUYrKezqA5ounx132rl+rKUdDu3mjPiHddGmA==\n-----END PUBLIC KEY-----\n'}
second_account = {'address': b'k|\x99`d\xc2\xa5%\xf3\xad`\x99rI+;\xb52\xfc!', 'priv_key': <cryptography.hazmat.bindings._rust.openssl.e...jPpA6J2wL4tUrRbBOKm7MLSNRET\nFzicEwicLqyWm1YF9qgTbk7cvdGS4l9nBJoQD3ksk+7ax9FSA6kEoT2BfQ==\n-----END PUBLIC KEY-----\n'}

    def test_double_spend_across_blocks(self, blockchain, funded_account, second_account):
        """Cannot reuse nonce across blocks."""
        # Create and process first transaction in block 1
        account = blockchain._get_account(funded_account['address'], blockchain.state_trie)
        account['balances']['native'] += 5000 # Ensure enough for fee
        blockchain._set_account(funded_account['address'], account, blockchain.state_trie)
    
        tx1 = Transaction(
            sender_public_key=funded_account['pub_key_pem'],
            tx_type='TRANSFER',
            data={
                'to': second_account['address'].hex(),
                'amount': 100 * TOKEN_UNIT,
                'token_type': 'native'
            },
            nonce=0,
            fee=1000,
            chain_id=1
        )
        tx1.sign(funded_account['priv_key'])
    
        # Create block with tx1
        latest = blockchain.get_latest_block()
        poh = PoHRecorder(latest.hash)
        poh.tick()
    
        from crypto_v2.trie import Trie
        temp_trie = Trie(blockchain.db, root_hash=latest.state_root)
>       blockchain._process_transaction(tx1, temp_trie)

crypto_v2/test_state_integrity.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <crypto_v2.chain.Blockchain object at 0x7f65afae91d0>
tx = <crypto_v2.core.Transaction object at 0x7f65b17dad70>
trie = <crypto_v2.trie.Trie object at 0x7f65afbcfe30>

    def _process_transaction(self, tx: Transaction, trie: Trie) -> bool:
        """
        Process a single transaction and update the state trie.
        This is the heart of the state transition logic.
        """
        sender_address = public_key_to_address(tx.sender_public_key)
        sender_account = self._get_account(sender_address, trie)
    
        # 0. Verify chain ID to prevent replay attacks
        if tx.chain_id != self.chain_id:
            raise ValidationError(f"Wrong chain ID. Expected {self.chain_id}, got {tx.chain_id}")
    
        # 1. Verify nonce
        if tx.nonce != sender_account['nonce']:
            raise ValidationError(f"Invalid nonce. Expected {sender_account['nonce']}, got {tx.nonce}")
    
        # 2. Increment nonce
        sender_account['nonce'] += 1
    
        # 3. Deduct fee
        sender_account['balances']['native'] -= tx.fee
        if sender_account['balances']['native'] < 0:
>           raise ValidationError("Insufficient funds for fee")
E           crypto_v2.chain.ValidationError: Insufficient funds for fee

crypto_v2/chain.py:406: ValidationError
========================================= short test summary info =========================================
FAILED crypto_v2/test_state_integrity.py::TestDoubleSpendPrevention::test_double_spend_across_blocks - crypto_v2.chain.ValidationError: Insufficient funds for fee
====================================== 1 failed, 15 passed in 0.29s =======================================
jonas@fedora:~/Downloads/NetPlay-master$ PYTHONPATH=. /home/jonas/Downloads/NetPlay-master/venv/bin/pytest /home/jonas/Downloads/NetPlay-master/crypto_v2/test_cryptographic_security.py
/home/jonas/Downloads/NetPlay-master/venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:207: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
=========================================== test session starts ===========================================
platform linux -- Python 3.13.7, pytest-8.3.5, pluggy-1.5.0
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/jonas/Downloads/NetPlay-master
plugins: cov-6.0.0, benchmark-5.1.0, asyncio-0.25.3
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None
collected 53 items                                                                                        

crypto_v2/test_cryptographic_security.py ................F....................................      [100%]

================================================ FAILURES =================================================
__________________________ TestBlockSignatures.test_tampered_transactions_fails ___________________________

self = <test_cryptographic_security.TestBlockSignatures object at 0x7f3696ada060>
blockchain = <crypto_v2.chain.Blockchain object at 0x7f36969e20d0>
keypair = {'address': b'\x10$\x85\xfe\xce\xcc\x15\xd1\xf5;\xc4\xc2\xb0\xf7:4C\xdd\x8a\t', 'priv_key': <cryptography.hazmat.bindi...w0DMlo4bSTlwgDoa+i51aqXjXIk\nxc6LK1Ykix8BX7WgEqAvjADyhCw3YHQypsdzqRAzxq7I2bEv1ZIvMd1aZA==\n-----END PUBLIC KEY-----\n'}

    def test_tampered_transactions_fails(self, blockchain, keypair):
        """Tampering with transactions invalidates block signature."""
        latest = blockchain.get_latest_block()
        poh = PoHRecorder(latest.hash)
        poh.tick()
    
        block = Block(
            parent_hash=latest.hash,
            state_root=latest.state_root,
            transactions=[],
            poh_sequence=poh.sequence,
            height=latest.height + 1,
            producer=keypair['pub_key_pem'],
            vrf_proof=b'test_proof',
            timestamp=time.time()
        )
    
        block.sign_block(keypair['priv_key'])
    
        # Add transaction after signing
        fake_tx = Transaction(
            sender_public_key=keypair['pub_key_pem'],
            tx_type='TRANSFER',
            data={'to': 'abc', 'amount': 100, 'token_type': 'native'},
            nonce=0,
            fee=1000,
            chain_id=1
        )
        block.transactions = block.transactions + [fake_tx]
    
        # Signature should fail (transactions root changed)
>       assert not block.verify_signature()
E       assert not True
E        +  where True = verify_signature()
E        +    where verify_signature = <crypto_v2.core.Block object at 0x7f3696b02b70>.verify_signature

crypto_v2/test_cryptographic_security.py:321: AssertionError
========================================= short test summary info =========================================
FAILED crypto_v2/test_cryptographic_security.py::TestBlockSignatures::test_tampered_transactions_fails - assert not True
====================================== 1 failed, 52 passed in 0.26s =======================================